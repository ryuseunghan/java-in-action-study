# 7.1 ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼

> ê°ê°ì˜ ìŠ¤ë ˆë“œì—ì„œ ì²˜ë¦¬í•  ìˆ˜ ìˆë„ë¡ ìŠ¤íŠ¸ë¦¼ ìš”ì†Œë¥¼ ì—¬ëŸ¬ ì²­í¬ë¡œ ë¶„í• í•œ ìŠ¤íŠ¸ë¦¼

## 7.1.1 ìˆœì°¨ ìŠ¤íŠ¸ë¦¼ì„ ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë³€í™˜í•˜ê¸°

## ì˜ˆì œ

### ë°˜ë³µë¬¸

```java
public long iterativeSum(long n) {
	long result = 0;
	for (long i = 1L; i <= n; i++) {
		result += i;
	}
	return result;
}
```

### ìˆœì°¨ ìŠ¤íŠ¸ë¦¼

```java
public long sequntialSum(long n) {
	return Stream.iterate(1L, i -> i + 1) // ë¬´í•œ ìì—°ìˆ˜ ìŠ¤íŠ¸ë¦¼ ìƒì„±
							 .limit(n) // nê°œ ì´í•˜ë¡œ ì œí•œ
							 .reduce(0L, Long::sum); // ëª¨ë“  ìˆ«ìë¥¼ ë”í•˜ëŠ” ìŠ¤íŠ¸ë¦¼ ë¦¬ë“€ì‹± ì—°ì‚°
}
```

### ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼

ë‹¤ìŒ ì½”ë“œì™€ ê°™ì´ ìˆœì°¨ ìŠ¤íŠ¸ë¦¼ì—ì„œ `parallel ë©”ì„œë“œ`ë¥¼ í˜¸ì¶œí•˜ë©´ ê¸°ì¡´ì˜ í•¨ìˆ˜í˜• ë¦¬ë“€ì‹± ì—°ì‚°ì´ ë³‘ë ¬ë¡œ ì²˜ë¦¬ëœë‹¤. ë¦¬ë“€ì‹± ì—°ì‚°ì€ ì—¬ëŸ¬ ì²­í¬ì— ë³‘ë ¬ë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤.

```java
public long parallelSum(long n) {
	return Stream.iterate(1L, i -> i + 1)
							 .limit(n)
							 .parallel() // ìŠ¤íŠ¸ë¦¼ì„ ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ë³€í™˜
							 .reduce(0L, Long::sum);
}
```

**parallel()ì„ í˜¸ì¶œí•´ë„ ì›ë³¸ ìŠ¤íŠ¸ë¦¼ì´ ë³€í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë‹¤!**

ì›ë³¸ ìŠ¤íŠ¸ë¦¼ ìì²´ê°€ ë³‘ë ¬í™” ë˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, ë³‘ë ¬ ì‹¤í–‰ ì—¬ë¶€ë¥¼ ì„¤ì •í•˜ëŠ” í”Œë˜ê·¸(flag)ë¥¼ ë³€ê²½í•˜ëŠ” ê²ƒ. ì¦‰, ìŠ¤íŠ¸ë¦¼ ì—°ì‚°ì´ ì‹¤ì œë¡œ ì‹¤í–‰ë  ë•Œ ë³‘ë ¬ë¡œ ìˆ˜í–‰ë˜ë„ë¡ ì„¤ì •í•œë‹¤.

### parallel()ê³¼ sequential()ì„ ì´ìš©í•´ì„œ ì—°ì‚° ì œì–´

parallel í˜¸ì¶œ ì´í›„, ì—°ì‚°ì´ **ë³‘ë ¬ë¡œ ìˆ˜í–‰**

sequential í˜¸ì¶œ ì´í›„, ì—°ì‚°ì´ **ìˆœì°¨ë¡œ ìˆ˜í–‰**

```java
stream.parallel()
			.filter(...) // ë³‘ë ¬ ìˆ˜í–‰
			.sequential()
			.map(...) // ìˆœì°¨ ìˆ˜í–‰
			.parallel()
			.reduce(); // ë³‘ë ¬ ìˆ˜í–‰
```

### ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ì—ì„œ ì‚¬ìš©í•˜ëŠ” ìŠ¤ë ˆë“œ í’€ ì„¤ì •

parallel() ë©”ì„œë“œëŠ” ë‚´ë¶€ì ìœ¼ë¡œ `ForkJoinPool`ì´ë¼ëŠ” ìŠ¤ë ˆë“œ í’€ì„ ì‚¬ìš©í•˜ì—¬ ë³‘ë ¬ ì—°ì‚°ì„ ìˆ˜í–‰í•œë‹¤.

ê¸°ë³¸ì ìœ¼ë¡œ ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ì€ CPU ì½”ì–´ ìˆ˜ë§Œí¼ì˜ ìŠ¤ë ˆë“œ ì‚¬ìš©í•˜ì§€ë§Œ, í•„ìš”ì— ë”°ë¼ ìŠ¤ë ˆë“œ ê°œìˆ˜ ë³€ê²½ ê°€ëŠ¥. ë‹¤ìŒ ì½”ë“œëŠ” ìµœëŒ€ 12ê°œì˜ ìŠ¤ë ˆë“œë¥¼ ì‚¬ìš©í•˜ë„ë¡ ì„¤ì •ë˜ì—ˆë‹¤.

But, **ì „ì—­ìœ¼ë¡œë°–ì— ë³€ê²½ì„ ëª» í•œë‹¤.** ë˜ë„ë¡ ê¸°ë³¸ê°’ ì‚¬ìš©í•˜ê¸°!

```java
System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", "12");
```

## 7.1.2 ìŠ¤íŠ¸ë¦¼ ì„±ëŠ¥ ì¸¡ì •

JMH(ìë°” ë§ˆì´í¬ë¡œ ë²¤ì¹˜ë§ˆí¬ í•˜ë‹ˆìŠ¤)ë¼ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì´ìš©í•´ ë²¤ì¹˜ë§ˆí¬ ì‘ì—…ì„ ì‹¤í–‰í•œë‹¤.

### ì˜ˆì œ

```java
@BenchmarkMode(Mode.AverageTime) // ë²¤ì¹˜ë§ˆí¬ ëŒ€ìƒ ë©”ì„œë“œë¥¼ ì‹¤í–‰í•˜ëŠ” ë° ê±¸ë¦° í‰ê·  ì‹œê°„ ì¸¡ì •
@OutputTimeUnit(TimeUnit.MILLISECONDS) // ë²¤ì¹˜ë§ˆí¬ ê²°ê³¼ë¥¼ ë°€ë¦¬ì´ˆ ë‹¨ìœ„ë¡œ ì¶œë ¥
@Fork(2, jvmArgs={"-Xms4G", "-Xms4G"})
public class ParallelStreamBenchmark {
	private static final long N = 10_000_000L;

	// ìˆœì°¨ ìŠ¤íŠ¸ë¦¼
	@Benchmark
	public long sequentialSum() {
		return Stream.iterate(1L. i -> i + 1).limit(N)
								 .reduce(0L, Long::sum);
	}

	// ì¼ë°˜ ë°˜ë³µë¬¸
	@Benchmark
	public long iterativeSum() {
		long result = 0;
		for(long i = 1L; i <= N; i++) {
			result += i;
		}
		return result;
	}

	// ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼
	@Benchmark
	public long parallelSum() {
		return Stream.iterate(1L. i -> i + 1).limit(N)
								 .parallel()
								 .reduce(0L, Long::sum);
	}

	// ë²¤ì¹˜ë§ˆí¬ ì‹¤í–‰ í›„ ê°€ë¹„ì§€ ì»¬ë ‰í„° ë™ì‘
	@TearDown(Level.Invocation)
	public void tearDown() {
		System.gc();
	}
}
```

### ì‹¤í–‰ ì‹œê°„ ë¹„êµ

**ì¼ë°˜ ë°˜ë³µë¬¸ < ìˆœì°¨ ìŠ¤íŠ¸ë¦¼ < ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼**

### ì™œ ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ì€ ì½”ì–´ CPUë¥¼ í™œìš© ëª»í•˜ê³  ëŠë¦¬ê²Œ ì‹¤í–‰ë˜ëŠ” ê±¸ê¹Œ?ğŸ¤”

- ë°˜ë³µ ê²°ê³¼ë¡œ ë°•ì‹±ëœ ê°ì²´ê°€ ë§Œë“¤ì–´ì§€ê¸°ì— ì—°ì‚°í•˜ê¸° ìœ„í•´ì„  ìˆ«ìë¡œ ì–¸ë°•ì‹±í•´ì•¼ í•¨
- ë°˜ë³µ ì‘ì—…ì€ ë³‘ë ¬ë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆëŠ” ë…ë¦½ ë‹¨ìœ„ë¡œ ë‚˜ëˆ„ê¸° ì–´ë ¤ì›€

**â–¶ï¸Â iterate ì—°ì‚°ì€ ì´ì „ ì—°ì‚°ì˜ ê²°ê³¼ì— ë”°ë¼ ë‹¤ìŒ í•¨ìˆ˜ì˜ ì…ë ¥ì´ ë‹¬ë¼ì§€ê¸°ì— ì²­í¬ë¡œ ë¶„í• í•˜ê¸° ì–´ë µë‹¤â€¼ï¸**

### ê·¸ë ‡ë‹¤ë©´?

`LongStream.rangeClosed(start, end)`ë¥¼ í†µí•´ ìµœì í™”ì‹œí‚¤ì!

ğŸ‘‰ğŸ»Â ê¸°ë³¸í˜• longì„ ì‚¬ìš©í•˜ê¸°ì— ë°•ì‹±/ì–¸ë°•ì‹± ì‘ì—…ì´ í•„ìš”ì—†ìŒ(ì˜¤ë²„í—¤ë“œ ê°ì†Œ)

ğŸ‘‰ğŸ»Â ì´ì „ ì—°ì‚°ì˜ ì˜í–¥ì„ ë°›ëŠ” iterateì™€ ë‹¬ë¦¬ ë²”ìœ„ë¥¼ ì§ì ‘ ì •í•´ì£¼ê¸°ì— ì²­í¬ë¡œ ì‰½ê²Œ ë¶„í• í•  ìˆ˜ ìˆìŒ

ğŸ‘‰ğŸ»Â ì‚¬ìš© í›„, ì „ì²´ì ìœ¼ë¡œ ì‹¤í–‰ ì‹œê°„ ê°ì†Œ, ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ ì‹¤í–‰ ì‹œê°„ < ìˆœì°¨ ìŠ¤íŠ¸ë¦¼ ì‹¤í–‰ ì‹œê°„

ì¦‰, í•­ìƒ parallel ë©”ì„œë“œì˜ ë³‘ë ¬í™” ì‘ì—…ì„ ì˜¬ë°”ë¥´ê²Œ ì‚¬ìš©í•˜ê³  ìˆëŠ”ì§€ ì£¼ì˜í•˜ì.

## 7.1.3 ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ì˜ ì˜¬ë°”ë¥¸ ì‚¬ìš©ë²•

ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ì˜ ë§ì€ ë¬¸ì œëŠ” **ê³µìœ ëœ ê°€ë³€ ìƒíƒœì—ì„œ ë¹„ë¡¯**ëœë‹¤.

```java
// ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼
public long sideEffectParallelSum(long n) {
	Accumulator accumulator = new Accumulator();
	LongStream.rangeClosed(1, n).parallel().forEach(accumulator::add);
	return accumulator.total;
}

// -> ìœ„ ê²°ê³¼ë¡œ ì˜¬ë°”ë¥¸ ê°’ì´ ë‚˜ì˜¤ì§€ ì•ŠëŠ”ë‹¤.
```

ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—ì„œ ê³µìœ ëœ add ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ë©´ì„œ ì˜¬ë°”ë¥¸ ê°’ì´ ë‚˜ì˜¤ì§€ ì•ŠëŠ” í˜„ìƒ ë°œìƒğŸš¨

â‡’ **ì¦‰, ì˜¬ë°”ë¥¸ ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ì„ ì‚¬ìš©í•˜ê³  ì‹¶ë‹¤ë©´ ê³µìœ ëœ ê°€ë³€ ìƒíƒœë¥¼ í”¼í•´ì•¼ í•œë‹¤.**

## 7.1.4 ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ íš¨ê³¼ì ìœ¼ë¡œ ì‚¬ìš©í•˜ê¸°

1. í™•ì‹ ì´ ì„œì§€ ì•Šìœ¼ë©´ ì§ì ‘ ì¸¡ì •í•˜ë¼.
2. ë°•ì‹±ì„ ì£¼ì˜í•˜ë¼. ê¸°ë³¸í˜• íŠ¹í™” ìŠ¤íŠ¸ë¦¼ì„ ì‚¬ìš©í•˜ë¼.
3. limitë‚˜ findFirstì²˜ëŸ¼ ìš”ì†Œì˜ ìˆœì„œì— ì˜ì¡´í•˜ëŠ” ì—°ì‚°ì—ì„œëŠ” ìˆœì°¨ ìŠ¤íŠ¸ë¦¼ë³´ë‹¤ ì„±ëŠ¥ì´ ë–¨ì–´ì§„ë‹¤.
4. ìŠ¤íŠ¸ë¦¼ì—ì„œ ìˆ˜í–‰í•˜ëŠ” ì „ì²´ íŒŒì´í”„ë¼ì¸ ì—°ì‚° ë¹„ìš©ì„ ê³ ë ¤í•˜ë¼.
5. ì†ŒëŸ‰ì˜ ë°ì´í„°ì—ì„œëŠ” ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ì´ ë„ì›€ì´ ì•ˆëœë‹¤.
6. ìŠ¤íŠ¸ë¦¼ì„ êµ¬ì„±í•˜ëŠ” ìë£Œêµ¬ì¡°ê°€ ì ì ˆí•œì§€ í™•ì¸í•˜ë¼. (í•˜ë‹¨ í‘œ ì°¸ê³ )
7. ìŠ¤íŠ¸ë¦¼ì˜ íŠ¹ì„±ê³¼ íŒŒì´í”„ë¼ì¸ì˜ ì¤‘ê°„ ì—°ì‚°ì´ ìŠ¤íŠ¸ë¦¼ì˜ íŠ¹ì„±ì„ ì–´ë–»ê²Œ ë°”ê¾¸ëŠ”ì§€ì— ë”°ë¼ ë¶„í•´ ê³¼ì • ì„±ëŠ¥ì´ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆë‹¤.
8. ìµœì¢… ì—°ì‚°ì˜ ë³‘í•© ê³¼ì • ë¹„ìš©ì„ ì‚´í´ë³´ë¼.
9. ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ì´ ìˆ˜í–‰ë˜ëŠ” ë‚´ë¶€ ì¸í”„ë¼ êµ¬ì¡°ë¥¼ ì‚´í´ë¼.

### ìŠ¤íŠ¸ë¦¼ ì†ŒìŠ¤ì™€ ë¶„í•´ì„±

| ì†ŒìŠ¤            | ë¶„í•´ì„± |
| --------------- | ------ |
| ArrayList       | í›Œë¥­í•¨ |
| LinkedList      | ë‚˜ì¨   |
| IntStream.range | í›Œë¥­í•¨ |
| Stream.iterate  | ë‚˜ì¨   |
| Hashset         | ì¢‹ìŒ   |
| TreeSet         | ì¢‹ìŒ   |

# 7.2 í¬í¬/ì¡°ì¸ í”„ë ˆì„ì›Œí¬

> ì„œë¸ŒíƒœìŠ¤í¬ë¥¼ ìŠ¤ë ˆë“œ í’€(ForkJoinPool)ì˜ ì‘ì—…ì ìŠ¤ë ˆë“œì— ë¶„ì‚° í• ë‹¹í•˜ëŠ” Executor ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„

## 7.2.1 RecursiveTask í™œìš©

ìŠ¤ë ˆë“œ í’€ì„ ì´ìš©í•˜ê¸° ìœ„í•´ RecursiveTask<R>ì˜ ì„œë¸Œí´ë˜ìŠ¤ë¥¼ ìƒì„±í•œë‹¤.

ì—¬ê¸°ì„œ **Rì€ ë³‘ë ¬í™”ëœ íƒœìŠ¤í¬ê°€ ìƒì„±í•œ ê²°ê³¼ í˜•ì‹ì´ê³  ë§Œì•½ ê²°ê³¼ê°€ ì—†ë‹¤ë©´ RecursiveAction í˜•ì‹**ì´ë‹¤.
ì´ ë•Œ, RecursiveActionì€ ì™¸ë¶€ ë°ì´í„°(ì „ì—­ ë³€ìˆ˜)ë¥¼ ì§ì ‘ ìˆ˜ì •í•˜ëŠ” ì—­í• ì„ ìˆ˜í–‰í•œë‹¤.

RecursiveTaskë¥¼ ì •ì˜í•˜ê¸° ìœ„í•´ ì¶”ìƒ ë©”ì„œë“œ computeë¥¼ êµ¬í˜„í•´ì•¼ í•œë‹¤.

`compute()` : íƒœìŠ¤í¬ë¥¼ ì„œë¸ŒíƒœìŠ¤í¬ë¡œ ë¶„í• í•˜ëŠ” ë¡œì§ê³¼ ë” ì´ìƒ ë¶„í• í•  ìˆ˜ ì—†ì„ ë•Œ ê°œë³„ ì„œë¸ŒíƒœìŠ¤í¬ì˜ ê²°ê³¼ë¥¼ ìƒì‚°í•  ì•Œê³ ë¦¬ì¦˜ì„ ì •ì˜

```java
protected abstract R compute();
```

### compute ë©”ì„œë“œì˜ ì˜ì‚¬ì½”ë“œ

```java
if (íƒœìŠ¤í¬ê°€ ì¶©ë¶„íˆ ì‘ê±°ë‚˜ ë” ì´ìƒ ë¶„í• í•  ìˆ˜ ì—†ìœ¼ë©´) {
	ìˆœì°¨ì ìœ¼ë¡œ íƒœìŠ¤í¬ ê³„ì‚°
} else {
	íƒœìŠ¤í¬ë¥¼ ë‘ ì„œë¸ŒíƒœìŠ¤í¬ë¡œ ë¶„í• 
	íƒœìŠ¤í¬ê°€ ë‹¤ì‹œ ì„œë¸ŒíƒœìŠ¤í¬ë¡œ ë¶„í• ë˜ë„ë¡ ì´ ë©”ì„œë“œë¥¼ ì¬ê·€ì ìœ¼ë¡œ í˜¸ì¶œí•¨
	ëª¨ë“  ì„œë¸ŒíƒœìŠ¤í¬ì˜ ì—°ì‚°ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¼
	ê° ì„œë¸ŒíƒœìŠ¤í¬ì˜ ê²°ê³¼ë¥¼ í•©ì¹¨
}
```

### RecursiveTaskì˜ compute ì¶”ìƒ ë©”ì„œë“œ ì˜¤ë²„ë¼ì´ë“œ

```java
@Override
protected Long compute() {
	int length = end - start;
	if (length <= THRESHOLD) {
		return computeSequentially();
	}
	ForkJoinSumCalculator leftTask =
	new ForkjoinSumCalculator(numbers, start, start + length / 2);

	// ì¤‘ìš”!!!
	leftTask.fork(); // ë³‘ë ¬ ì‹¤í–‰

	ForkJoinSumCalculator rightTask =
	new ForkJoinSumCalculator(numbers, start + length / 2, end);

	Long rightResult = rightTask.compute();
	Long leftResult = leftTask.join();
	return leftResult + rightResult;
}
```

compute()ë¥¼ ì‹¤í–‰í•˜ê³  ìˆëŠ” AìŠ¤ë ˆë“œê°€ leftTask.fork()ë¥¼ í˜¸ì¶œí•˜ë©° BìŠ¤ë ˆë“œì—ì„œ leftTaskë¥¼ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì‹¤í–‰í•œë‹¤.

**ê·¸ëŸ¼, rightTaskë„ ë˜‘ê°™ì´ rightTask.fork()ë¥¼ í˜¸ì¶œí•˜ë©´ ë˜ì§€ ì•Šì„ê¹Œ?**

â¡ï¸ ê·¸ëŸ¬ë©´ CìŠ¤ë ˆë“œë¥¼ ìƒˆë¡­ê²Œ í• ë‹¹í•´ì¤˜ì•¼ í•œë‹¤.
ê·¸ ì˜¤ë²„í—¤ë“œë¥¼ ì¤„ì´ê¸° ìœ„í•´, compute()ë¥¼ ì‹¤í–‰í•˜ê³  ìˆëŠ” AìŠ¤ë ˆë“œì—ì„œ ì­‰ ì§„í–‰í•˜ë©´ ëœë‹¤! ê·¸ëŸ¬ê¸° ìœ„í•´ì„  fork()ê°€ ì•„ë‹Œ rightTask.compute(...)ë¥¼ í•˜ë©´ ë¹„ìš©ì„ ì ˆì•½í•  ìˆ˜ ìˆë‹¤.

### ForkJoinSumCalculatorë¥¼ í™œìš©í•œ ì˜ˆì œ ì½”ë“œ

ë‹¤ìŒ ì½”ë“œëŠ” ìˆ«ì nê¹Œì§€ì˜ ë³‘ë ¬ í•©ì‚°ì„ ìˆ˜í–‰í•œ ì½”ë“œë‹¤.

```java
public static long forkJoinSum(long n){
	long[] numbers = LongStream.rangeClosed(1, n).toArray();
	ForkJoinTask<Long> task = new ForkJoinSumCalculator(numbers); // ìœ„ ì½”ë“œì¸ ë³‘ë ¬ í•©ì‚° ì•Œê³ ë¦¬ì¦˜ ìˆ˜í–‰
	return new ForkJoinPool().invoke(task); // ìƒì„±í•œ íƒœìŠ¤í¬ë¥¼ invoke ë©”ì„œë“œë¡œ ì „ë‹¬
}
```

ìœ„ ì½”ë“œì—ì„œ invoke(task)ë¥¼ í˜¸ì¶œí•˜ëŠ” ì´ìœ ëŠ” ForkJoinPoolì´ ë³‘ë ¬ ì‘ì—…ì„ ì‹œì‘í•˜ê³ , ê²°ê³¼ë¥¼ ë°˜í™˜ë°›ê¸° ìœ„í•´ì„œë‹¤.
êµ¬ì²´ì ìœ¼ë¡œ invoke()ëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì—­í• ì„ í•œë‹¤.

### invoke()ì˜ ì—­í• 

1. **ForkJoinPoolì—ì„œ ì‘ì—…(task) ì‹¤í–‰** :
   invoke(ForkJoinTask<T> task)ëŠ” ì£¼ì–´ì§„ ForkJoinTaskë¥¼ í˜„ì¬ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰í•˜ê³  ê²°ê³¼ë¥¼ ë°˜í™˜í•œë‹¤.
   ë‚´ë¶€ì ìœ¼ë¡œ ìŠ¤ë ˆë“œ í’€ì„ í™œìš©í•˜ì—¬ ë³‘ë ¬ë¡œ ì‘ì—…ì„ ìˆ˜í–‰í•œë‹¤.

2. **ê²°ê³¼ ë°˜í™˜** :
   invoke()ëŠ” ì‘ì—…ì´ ëë‚  ë•Œê¹Œì§€ ê¸°ë‹¤ë ¸ë‹¤ê°€(join()ê³¼ ìœ ì‚¬) ìµœì¢… ê²°ê³¼ë¥¼ ë°˜í™˜í•œë‹¤.
   ì¦‰, ë³‘ë ¬ ì—°ì‚°ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ë©”ì¸ ìŠ¤ë ˆë“œëŠ” ëŒ€ê¸°í•˜ë©°, ì™„ë£Œëœ ê²°ê³¼ë¥¼ ë¦¬í„´í•œë‹¤.

3. **ForkJoinTaskì˜ ì‹¤í–‰ì„ ì¤‘ì•™ ì§‘ì¤‘í™”** : invoke()ëŠ” ì§ì ‘ ForkJoinTaskë¥¼ ì‹¤í–‰í•˜ë©°, fork() ë° join()ì„ ìˆ˜ë™ìœ¼ë¡œ í˜¸ì¶œí•˜ëŠ” ê²ƒë³´ë‹¤ ê°„ê²°í•˜ê²Œ ë³‘ë ¬ ì‘ì—…ì„ ì‹¤í–‰í•  ìˆ˜ ìˆë‹¤.

**invoke()ê°€ ì—†ìœ¼ë©´?**

ë§Œì•½ invoke(task)ë¥¼ í˜¸ì¶œí•˜ì§€ ì•Šê³ , ë‹¨ìˆœíˆ task.fork();ë§Œ í˜¸ì¶œí•˜ë©´ ë©”ì¸ ìŠ¤ë ˆë“œê°€ ì¦‰ì‹œ ë°˜í™˜ë˜ì–´, ì—°ì‚°ì´ ì™„ë£Œë˜ì§€ ì•Šì€ ìƒíƒœì—ì„œ ê°’ì´ ë¦¬í„´ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
ë”°ë¼ì„œ invoke()ë¥¼ í˜¸ì¶œí•´ì•¼ ForkJoinPoolì´ ì—°ì‚°ì„ ë§ˆì¹  ë•Œê¹Œì§€ ê¸°ë‹¤ë ¸ë‹¤ê°€ ìµœì¢… ê²°ê³¼ë¥¼ ë°˜í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**ì¼ë°˜ì ìœ¼ë¡œ ForkJoinPoolì€ ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ë‹¨ í•œ ë²ˆë§Œ ì¸ìŠ¤í„´ìŠ¤í™” í•´ì„œ ì •ì  í•„ë“œì— ì‹±ê¸€í„´ìœ¼ë¡œ ì €ì¥**í•œë‹¤.

ForkJoinSumCalculatorì˜ compute ë©”ì„œë“œëŠ” ë³‘ë ¬ë¡œ ì‹¤í–‰í•  ìˆ˜ ìˆì„ë§Œí¼ íƒœìŠ¤í¬ì˜ í¬ê¸°ê°€ ì‘ì•„ì¡ŒëŠ”ì§€ í™•ì¸í•˜ë©°, ì•„ì§ íƒœìŠ¤í¬ì˜ í¬ê¸°ê°€ í¬ë‹¤ê³  íŒë‹¨ë˜ë©´ ìˆ«ì ë°°ì—´ì„ ë°˜ìœ¼ë¡œ ë¶„í• í•´ì„œ ë‘ ê°œì˜ ìƒˆë¡œìš´ ForkJoinSumCalculatorë¡œ í• ë‹¹í•œë‹¤.

â‡’ **ì¬ê·€ì ì¸ íƒœìŠ¤í¬ ë¶„í•  ë°˜ë³µ**

## 7.2.2 í¬í¬/ì¡°ì¸ í”„ë ˆì„ì›Œí¬ë¥¼ ì œëŒ€ë¡œ ì‚¬ìš©í•˜ëŠ” ë°©ë²•

- join ë©”ì„œë“œë¥¼ íƒœìŠ¤í¬ì— í˜¸ì¶œí•˜ë©´ íƒœìŠ¤í¬ê°€ ìƒì‚°í•˜ëŠ” ê²°ê³¼ê°€ ì¤€ë¹„ë  ë•Œê¹Œì§€ í˜¸ì¶œìë¥¼ ë¸”ë¡ì‹œí‚¨ë‹¤. join ë©”ì„œë“œëŠ” ë‘ ì„œë¸ŒíƒœìŠ¤í¬ê°€ ëª¨ë‘ ì‹œì‘ëœ ë‹¤ìŒì— í˜¸ì¶œí•˜ì.
- RecursiveTask ë‚´ì—ì„œëŠ” ForkJoinPoolì˜ invoke ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì§€ ë§ì•„ì•¼ í•œë‹¤. ëŒ€ì‹  computeë‚˜ fork ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ì.
- ì™¼ìª½ ì‘ì—…ê³¼ ì˜¤ë¥¸ìª½ ëª¨ë‘ì— fork ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒ ëŒ€ì‹ , í•œìª½ ì‘ì—…ì— computeë¥¼ í˜¸ì¶œí•˜ì. ë‘ ì„œë¸ŒíƒœìŠ¤í¬ì˜ í•œ íƒœìŠ¤í¬ì—ëŠ” ê°™ì€ ìŠ¤ë ˆë“œë¥¼ ì¬ì‚¬ìš©í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ í’€ì—ì„œ ë¶ˆí•„ìš”í•œ íƒœìŠ¤í¬ë¥¼ í• ë‹¹í•˜ëŠ” ì˜¤ë²„í—¤ë“œë¥¼ ì¤„ì¼ ìˆ˜ ìˆë‹¤.
- ë””ë²„ê¹…ì´ ì–´ë µë‹¤ëŠ” ì ì„ ê³ ë ¤í•˜ì.
- ê° ì„œë¸ŒíƒœìŠ¤í¬ì˜ ì‹¤í–‰ì‹œê°„ì€ ìƒˆë¡œìš´ íƒœìŠ¤í¬ë¥¼ í¬í‚¹í•˜ëŠ” ë° ë“œëŠ” ì‹œê°„ë³´ë‹¤ ê¸¸ì–´ì•¼ í•œë‹¤.

## 7.2.3 ì‘ì—… í›”ì¹˜ê¸°

ì½”ì–´ ê°œìˆ˜ë§Œí¼ ë³‘ë ¬í™”ëœ íƒœìŠ¤í¬ë¡œ ì‘ì—… ë¶„í• ì„ í•˜ë©´ ëª¨ë“  CPU ì½”ì–´ì—ì„œ íƒœìŠ¤í¬ë¥¼ ì‹¤í–‰í•  ê²ƒì´ê³  í¬ê¸°ê°€ ê°™ì€ íƒœìŠ¤í¬ë“¤ì€ ê°™ì€ ì‹œê°„ì— ì¢…ë£Œë  ê²ƒì´ë¼ ìƒê°í•˜ê² ì§€ë§Œ, ì‹¤ì œ í˜„ì‹¤ì—ì„œëŠ” ì‘ì—… ì™„ë£Œ ì‹œê°„ì´ í¬ê²Œ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆë‹¤. ë¶„í•  ê¸°ë²•ì´ íš¨ìœ¨ì ì´ì§€ ì•Šì•˜ê±°ë‚˜ ì˜ˆê¸°ì¹˜ ì•Šì€ ë””ìŠ¤í¬ ì ‘ê·¼ ì†ë„ ì €í•˜ ë° ì™¸ë¶€ ì„œë¹„ìŠ¤ì™€ì˜ ì§€ì—° ê³¼ì • ë•Œë¬¸ì´ë‹¤.

í¬í¬/ì¡°ì¸ í”„ë ˆì„ì›Œí¬ì—ì„œëŠ” ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ **â€œì‘ì—… í›”ì¹˜ê¸° ê¸°ë²•â€**ì„ ì‚¬ìš©í•œë‹¤.

### ì‘ì—… í›”ì¹˜ê¸° ê³¼ì •

â‡’ ê°ê°ì˜ ìŠ¤ë ˆë“œëŠ” ìì‹ ì—ê²Œ í• ë‹¹ëœ íƒœìŠ¤í¬ë¥¼ í¬í•¨í•˜ëŠ” ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸(doubley linked list)ë¥¼ ì°¸ì¡°í•˜ë©´ì„œ ì‘ì—…ì´ ëë‚  ë•Œë§ˆë‹¤ íì˜ í—¤ë“œì—ì„œ ë‹¤ë¥¸ íƒœìŠ¤í¬ë¥¼ ê°€ì ¸ì™€ì„œ ì‘ì—…ì„ ì²˜ë¦¬

â‡’ ì´ ë•Œ, í•œ ìŠ¤ë ˆë“œëŠ” ë‹¤ë¥¸ ìŠ¤ë ˆë“œë³´ë‹¤ ìì‹ ì—ê²Œ í• ë‹¹ëœ íƒœìŠ¤í¬ë¥¼ ë” ë¹¨ë¦¬ ì²˜ë¦¬í•  ìˆ˜ ìˆëŠ”ë°, í•  ì¼ì´ ì—†ì–´ì§„ ìŠ¤ë ˆë“œëŠ” ìœ íœ´ ìƒíƒœë¡œ ë°”ë€ŒëŠ” ê²ƒì´ ì•„ë‹ˆë¼ **ë‹¤ë¥¸ ìŠ¤ë ˆë“œì˜ íì˜ ê¼¬ë¦¬ì—ì„œ ì‘ì—…ì„ í›”ì³ì˜¨ë‹¤.**

â‡’ ëª¨ë“  íƒœìŠ¤í¬ê°€ ì‘ì—…ì„ ëë‚¼ ë•Œ ê¹Œì§€ ì´ ê³¼ì •ì„ ë°˜ë³µí•œë‹¤.

ë”°ë¼ì„œ, íƒœìŠ¤í¬ì˜ í¬ê¸°ë¥¼ ì‘ê²Œ ë‚˜ëˆ„ì–´ì•¼ ì‘ì—…ì ìŠ¤ë ˆë“œ ê°„ì˜ ì‘ì—…ë¶€í•˜ë¥¼ ë¹„ìŠ·í•œ ìˆ˜ì¤€ìœ¼ë¡œ ìœ ì§€í•  ìˆ˜ ìˆë‹¤.

# 7.3 Spliterator ì¸í„°í˜ì´ìŠ¤

> ìë™ìœ¼ë¡œ ìŠ¤íŠ¸ë¦¼ì„ ë¶„í• í•˜ëŠ” ê¸°ë²•

### Spliterator ì¸í„°í˜ì´ìŠ¤ ë©”ì„œë“œ

```java
public interface Spliterator<T> {
	boolean tryAdvance(Consumer<? super T> action);
	Spliterator<T> trySplit();
	long estimateSize();
	int characteristics();
}
```

- **T** : Spliteratorì—ì„œ íƒìƒ‰í•˜ëŠ” ìš”ì†Œì˜ í˜•ì‹
- **tryAdvance** : Spliteratorì˜ ìš”ì†Œë¥¼ í•˜ë‚˜ì”© ìˆœì°¨ì ìœ¼ë¡œ ì†Œë¹„í•˜ë©´ì„œ íƒìƒ‰í•´ì•¼ í•  ìš”ì†Œê°€ ë‚¨ì•„ìˆìœ¼ë©´ ì°¸ì„ ë°˜í™˜
- **trySplit** : Spliteratorì˜ ì¼ë¶€ ìš”ì†Œë¥¼ ë¶„í• í•´ì„œ ë‘ ë²ˆì§¸ Spliteratorë¥¼ ìƒì„±í•˜ëŠ” ë©”ì„œë“œ
- **estimateSize** : íƒìƒ‰í•´ì•¼ í•  ìš”ì†Œ ìˆ˜ ì •ë³´ë¥¼ ì œê³µ
- **characteristics** : Spliterì˜ íŠ¹ì„±

### Spliterator íŠ¹ì„±

- **ORDERED**: ì •í•´ì§„ ìˆœì„œì— ë”°ë¼ ìš”ì†Œë¥¼ íƒìƒ‰í•˜ê³  ë¶„í• í•  ë•Œ ìˆœì„œì— ìœ ì˜í•´ì•¼ í•œë‹¤.
- **DISTINCT**: x, y ë‘ ìš”ì†Œë¥¼ ë°©ë¬¸í–ˆì„ ë•Œ x.equals(y)ëŠ” í•­ìƒ falseë¥¼ ë°˜í™˜í•œë‹¤.
- **SORTED**: íƒìƒ‰ëœ ìš”ì†ŒëŠ” ë¯¸ë¦¬ ì •ì˜ëœ ì •ë ¬ ìˆœì„œë¥¼ ë”°ë¥¸ë‹¤.
- **SIZED**: í¬ê¸°ê°€ ì•Œë ¤ì§„ ì†ŒìŠ¤ë¡œ Spliteratorë¥¼ ìƒì„±í–ˆìœ¼ë¯€ë¡œ estimatedSize()ëŠ” ì •í™•í•œ ê°’ì„ ë°˜í™˜
- **NON-NULL**: íƒìƒ‰í•˜ëŠ” ëª¨ë“  ìš”ì†ŒëŠ” nullì´ ì•„ë‹ˆë‹¤.
- **IMMUTABLE**: SpliteratorëŠ” ë³€í•  ìˆ˜ ì—†ë‹¤. ì¦‰, ìš”ì†Œë¥¼ íƒìƒ‰í•˜ëŠ” ë™ì•ˆ ìš”ì†Œë¥¼ ë³€í™”ì‹œí‚¬ ìˆ˜ ì—†ë‹¤.
- **CONCURRENT**: ë™ê¸°í™” ì—†ì´ Spliteratorì˜ ì†ŒìŠ¤ë¥¼ ì—¬ëŸ¬ ìŠ¤ë ˆë“œì—ì„œ ë™ì‹œì— ê³ ì¹  ìˆ˜ ìˆë‹¤.
- **SUBSIZED**: Spliteratorì™€ ê·¸ë¡œ ì¸í•´ ë¶„í• ëœ SpliteratorëŠ” ëª¨ë‘ SIZED íŠ¹ì„±ì„ ê°–ëŠ”ë‹¤.

## 7.3.2 ì»¤ìŠ¤í…€ Spliterator êµ¬í˜„í•˜ê¸°

### í•¨ìˆ˜í˜•ìœ¼ë¡œ ë‹¨ì–´ ìˆ˜ë¥¼ ì„¸ëŠ” ë©”ì„œë“œ ì¬êµ¬í˜„í•˜ê¸°

```java
class WordCounter {
	private final int counter;
	private final boolean lastSpace;
	public WordCounter(int counter, boolean lastSpace) {
		this.counter = counter;
		this.lastSpace = lastSpace;
	}
	public WordCounter accumulate(Character c) { // ë¬¸ìì—´ì˜ ë¬¸ìë¥¼ í•˜ë‚˜ì”© íƒìƒ‰
		if(Character.isWhitespace()) {
			return lastSpace ?
				this :
				new WordCounter(counter, true);
			} else {
				return lastSpace ?
					new WordCounter(counter+1, false) : // íƒìƒ‰í•˜ë‹¤ ê³µë°±ì„ ë§Œë‚˜ë©´ ì§€ê¸ˆê¹Œì§€ íƒìƒ‰í•œ ë¬¸ìë¥¼ í•˜ë‚˜ë¡œ ê°„ì£¼í•˜ì—¬ ë‹¨ì–´ ìˆ˜ ì¦ê°€
					this;
			}
		}
	}
	public WordCounter combine(WordCounter wordCounter) {
		return new WordCounter(counter + wordCounter.counter, wordCounter.lastSpace);
	}
	public int getCounter() {
		return counter;
	}
}
```

1. accumulate ë©”ì„œë“œë¥¼ í†µí•´ ìƒˆë¡œìš´ ë¬¸ìë¥¼ íƒìƒ‰í–ˆì„ ë•Œ WordCounter ìƒíƒœ ë³€ì´
2. combine ë©”ì„œë“œë¥¼ í†µí•´ ë¬¸ìì—´ ì„œë¸Œ ìŠ¤íŠ¸ë¦¼ì„ ì²˜ë¦¬í•œ WordCounterì˜ ê²°ê³¼ë¥¼ ë³‘í•©(WordCounter ë‚´ë¶€ counter ê°’ ë³‘í•©)

### ë¬¸ì ìŠ¤íŠ¸ë¦¼ì˜ ë¦¬ë“€ì‹± ì—°ì‚°(ìˆœì°¨ì )

```java
private int countWords(Stream<Character> stream) {
	WordCounter wordCounter = stream.reduce(new WordCounter(0, true),
												WordCounter::accumulate,
												WordCounter::combine;
	return wordCounter.getCounter();
}

Stream<Character> stream = IntStream.range(0, SENTENCE.length())
									.mapToObj(SENTENCE::charAt());
System.out.println("Found " + countWords(stream)+ " words");
```

### ë¬¸ì ìŠ¤íŠ¸ë¦¼ì˜ ë¦¬ë“€ì‹± ì—°ì‚°(ë³‘ë ¬ì )

ë‹¤ìŒ ë³‘ë ¬ ì‹¤í–‰ ì½”ë“œëŠ” ìœ„ ìˆœì°¨ ë¦¬ë“€ì‹± ì—°ì‚°ë³´ë‹¤ ë‹¨ì–´ê°€ ë§ì´ ë‚˜íƒ€ë‚˜ëŠ” ìƒí™© ë°œìƒ

```java
System.out.println("Found " + countWords(stream.parallel()) + " words");
```

ì™œ ê·¸ëŸ´ê¹Œ?ğŸ¤”

> ì˜ëª»ëœ ìŠ¤íŠ¸ë¦¼ ë¶„í•  ìœ„ì¹˜ë¡œ ì¸í•´ ê³µë°± ê¸°ì¤€ìœ¼ë¡œ ë‹¨ì–´ë¥¼ ë‚˜ëˆ„ëŠ” ê²ƒì´ ì•„ë‹Œ í•˜ë‚˜ì˜ ë‹¨ì–´ë¥¼ ë‘˜ë¡œ ë‚˜ëˆ„ì–´ë²„ë ¤ì„œ ë‚˜íƒ€ë‚œ ìƒí™©

### Spliteratorë¥¼ í™œìš©í•œ í•´ê²°ë°©ë²•

Spliteratorë¥¼ ì´ìš©í•´ì„œ ë‹¨ì–´ê°€ ëë‚˜ëŠ” ìœ„ì¹˜ì—ì„œ ë¶„í• í•˜ë„ë¡ í•œë‹¤.

```java
class WordCounterSpliterator implements Spliterator<Character> {
	private final String string;
    private int currentChar = 0;
    public WordCounterSpliterator(String string) {
    	this.string = string;
    }
    @Override
    public boolean tryAdvance(Consumer<? super Character> action) {
    	action.accept(string.charAt(currentChar++)); // í˜„ì¬ ë¬¸ìë¥¼ ì†Œë¹„í•œë‹¤.
        return currentChar < string.length(); // ì†Œë¹„í•  ë¬¸ìê°€ ë‚¨ì•„ìˆìœ¼ë©´ trueë¥¼ ë°˜í™˜í•œë‹¤.
    }
    @Override
    public Spliterator<Character> trySplit() {
    	int currentSize = string.length() - currentChar;
        if (currentSize < 10) {
        	return null; // íŒŒì‹±í•  ë¬¸ìì—´ì„ ìˆœì°¨ ì²˜ë¦¬í•  ìˆ˜ ìˆì„ ë§Œí¼ ì¶©ë¶„íˆ ì‘ì•„ì¡ŒìŒì„ ì•Œë¦¬ëŠ” nullì„ ë°˜í™˜í•œë‹¤.
        }
        for (int splitPos = currentSize / 2 + currentChar;
        		splitPos < string.length(); splitPost++) { // íŒŒì‹±í•  ë¬¸ìì—´ì˜ ì¤‘ê°„ì„ ë¶„í•  ìœ„ì¹˜ë¡œ ì„¤ì •í•œë‹¤.
            if (Character.isWhitespace(string.charAt(splitPos))) { // ë‹¤ìŒ ê³µë°±ì´ ë‚˜ì˜¬ ë•Œê¹Œì§€ ë¶„í•  ìœ„ì¹˜ë¥¼ ë’¤ë¡œ ì´ë™ ì‹œí‚¨ë‹¤.
            	Spliterator<Character> spliterator = // ì²˜ìŒë¶€í„° ë¶„í•  ìœ„ì¹˜ê¹Œì§€ ë¬¸ìì—´ì„ íŒŒì‹±í•  ìƒˆë¡œìš´ WordCounterSpliteratorë¥¼ ìƒì„±í•œë‹¤.
                	new WordCounterSpliterator(string.substring(currentChar, splitPos));
                    currentChar = splitPos; // ì´ WordCounterSpliteratorì˜ ì‹œì‘ ìœ„ì¹˜ë¥¼ ë¶„í•  ìœ„ì¹˜ë¡œ ì„¤ì •í•œë‹¤.
                    return spliterator;	// ê³µë°±ì„ ì°¾ì•˜ê³  ë¬¸ìì—´ì„ ë¶„ë¦¬í–ˆìœ¼ë¯€ë¡œ ë£¨í”„ë¥¼ ì¢…ë£Œí•œë‹¤.
            }
        }
        return null;
    }
    @Override
    public long estimateSize() {
    	return string.length() - currentChar;
    }
    @Override
    public int characteristics() {
    	return ORDERED + SIZED + SUBSIZED + NON-NULL + IMMUTABLE;
    }
}
```

WordCounterSpliteratorë¥¼ í™œìš©í•˜ë©´ ë³‘ë ¬ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì‚¬ìš©í•˜ë©´ ì•ì„  ìˆœì°¨ ë¦¬ë“€ì‹± ì—°ì‚°ë³´ë‹¤ ë‹¨ì–´ê°€ ë§ì´ ë‚˜íƒ€ë‚˜ëŠ” ë³‘ë ¬ ë¦¬ë“€ì‹± ë¬¸ì œë¥¼ í•´ê²°í•  ìˆ˜ ìˆë‹¤.

```java
Spliterator<Character> spliterator = new SimpleSpliterator(SENTENCE);
Stream<Character> stream = StreamSupport.stream(spliterator, true);

System.out.println("Found " + countWords(stream) + " words");
```
